---
title: "Sta 440 Case 3"
author: "Sreya Gnanavel, Yura Heo, Lily Seelig"
date: "September 2025"
format: 
  pdf:
    documentclass: article
    fontsize: 11pt
geometry: margin=1in
execute: 
  warning: false
  message: false
  echo: false
---

```{r}
#| label: load_packages

library(tidyverse)
library(lubridate)
library(janitor)    
library(scales)
install.packages("performance")

```

```{r}
#| label: data

load("emsData.RData")



glimpse(x)
ems <- x


```

```{r}
ems <- ems %>%
  mutate(
    mins_dispatch_to_enroute = as.numeric(timeToEnroute, units = "mins"),
    mins_enroute_to_arrival  = as.numeric(observedTT, units = "mins"),
    mins_dispatch_to_arrival = as.numeric(difftime(DT.ARRIVE, DT.DISP, units = "mins")),
    mins_on_scene            = as.numeric(onSceneDur, units = "mins"),
    mins_to_hospital         = as.numeric(toHospitalTT, units = "mins"),
    mins_turnaround          = as.numeric(difftime(DT.AVAILABLE, DT.ARVREC, units = "mins")),
    
    call_date = as_date(DT.DISP),
    dow       = wday(DT.DISP, label = TRUE, abbr = TRUE),
    hour      = hour(DT.DISP)
  )


# sanity check
ems %>%
  summarise(across(starts_with("mins_"), 
                   list(min = ~min(.x, na.rm = TRUE),
                        max = ~max(.x, na.rm = TRUE))))

```

```{r}
#| label: add scenario

# pmin: minimum travel time across the stafed stations 

ems <- ems %>%
  mutate(
    # S0 (Current: 3 Central, 1 South)
    resp_S0 = pmin(eTT.BG.Ce, eTT.BG.So, na.rm = TRUE),

    # S1 (3 Central, 1 Near North)
    resp_S1 = pmin(eTT.BG.Ce, eTT.BG.NN, na.rm = TRUE),

    # S2 (3 Central, 1 Far North)
    resp_S2 = pmin(eTT.BG.Ce, eTT.BG.FN, na.rm = TRUE),

    # S3 (2 Central, 1 South, 1 Near North)
    resp_S3 = pmin(eTT.BG.Ce, eTT.BG.So, eTT.BG.NN, na.rm = TRUE),

    # S4 (2 Central, 1 South, 1 Far North)
    resp_S4 = pmin(eTT.BG.Ce, eTT.BG.So, eTT.BG.FN, na.rm = TRUE)
  )
```

```{r}
ems %>%
  select(eTT.BG.NN, eTT.BG.FN) %>%
  pivot_longer(cols = everything(), names_to = "Station", values_to = "Time") %>%
  mutate(Time = Time/60) %>%
  ggplot(aes(x = Time, fill = Station)) +
  geom_density(alpha=0.4) +
  labs(title="Estimated Travel Times: Near vs Far North (Best Guess)",
       x="Minutes", y="Density")
summary(ems$eTT.BG.NN/60)
summary(ems$eTT.BG.FN/60)

ems %>%
  mutate(current_central = eTT.BG.Ce/60,
         current_south = eTT.BG.So/60,
         near_north = eTT.BG.NN/60,
         far_north = eTT.BG.FN/60) %>%
  pivot_longer(cols = c(current_central, current_south, near_north, far_north),
               names_to = "Scenario", values_to = "Minutes") %>%
  ggplot(aes(x = Minutes, fill = Scenario)) +
  geom_density(alpha=0.4) +
  labs(title="Travel Time Distributions Under Different Allocations")
```

```{r}
ems %>%
  pivot_longer(starts_with("resp_S"), names_to = "scenario", values_to = "resp_time") %>%
  group_by(scenario) %>%
  summarise(
    mean = mean(resp_time, na.rm = TRUE),
    median = median(resp_time, na.rm = TRUE),
    p90 = quantile(resp_time, 0.9, na.rm = TRUE)
  )
```

```{r}
ems %>%
  pivot_longer(starts_with("resp_S"), names_to = "scenario", values_to = "resp_time") %>%
  ggplot(aes(resp_time, fill = scenario)) +
  geom_density(alpha = 0.4) +
  coord_cartesian(xlim = c(0, 2000)) +   # adjust limit if needed
  labs(title = "Response time distributions across scenarios",
       x = "Estimated response time (seconds)", y = "Density")
```

```{r}
ems %>%
  pivot_longer(starts_with("resp_S"), names_to = "scenario", values_to = "resp_time") %>%
  mutate(resp_time_min = resp_time / 60) %>%
  ggplot(aes(scenario, resp_time_min, fill = scenario)) +
  geom_boxplot(outlier.shape = NA) +
  coord_cartesian(ylim = c(0, 20)) +   # 1000 sec ≈ 16.7 min
  labs(title = "Response time by scenario",
       x = "Scenario", y = "Estimated response time (minutes)") +
  theme(legend.position = "none")
```

The figure above compares estimated response times under five station-allocation scenarios by constructing, for each call, the minimum best-guess travel time among the stations staffed in that scenario and summarizing these distributions with boxplots. System-wide, scenario S3 (adding a station in Near-North) exhibits the lowest median response time and a comparatively tight interquartile range, indicating improvements over the current configuration (S0). Scenarios S1 and S2 do not improve system-level medians relative to S0, whereas S4 performs between S0 and S3.

```{r}
regional_summary <- ems %>%
  group_by(REF.GRID) %>%
  summarise(across(starts_with("resp_"),
                   list(mean = ~mean(.x, na.rm=TRUE)/60,
                        median = ~median(.x, na.rm=TRUE)/60,
                        p90 = ~quantile(.x, 0.9, na.rm=TRUE)/60)))

regional_summary

```

### Boxplot

```{r}

ems_long <- ems %>%
  select(REF.GRID, starts_with("resp_S")) %>%
  pivot_longer(cols = starts_with("resp_S"), 
               names_to = "Scenario", values_to = "RespTime") %>%
  mutate(
    Scenario = gsub("resp_", "", Scenario),   # cleaner scenario names
    RespTime_min = RespTime / 60
  )

ggplot(ems_long, aes(x = Scenario, y = RespTime_min, fill = Scenario)) +
  geom_boxplot(outlier.alpha = 0.2) +
  facet_wrap(~REF.GRID, scales = "free_y") +
  geom_hline(yintercept=8, linetype="dashed", color="red") +
  labs(title="Response Times Across Scenarios by District",
       subtitle="Dashed red line = 8-minute benchmark",
       x="Scenario", y="Response Time (minutes)") +
  theme_minimal() +
  theme(legend.position="none",
        strip.text = element_text(size=12, face="bold"))
```

```{r}
ems_long %>%
  group_by(Scenario, REF.GRID) %>%
  summarise(pct_under8 = mean(RespTime_min <= 8, na.rm=TRUE)*100) %>%
  ggplot(aes(x=Scenario, y=pct_under8, fill=REF.GRID)) +
  geom_col(position="dodge") +
  labs(title="% of Calls Under 8-min by Scenario and District",
       y="% Calls < 8 min", x="Scenario", fill="District") +
  theme_minimal()
```

```{r}

station_names <- c(
  "eTT.BG.Ce" = "Central",
  "eTT.BG.So" = "South",
  "eTT.BG.NN" = "Near North",
  "eTT.BG.FN" = "Far North"
)

station_palette <- c(
  "Central"    = "#1f77b4",
  "South"      = "#ff7f0e",
  "Near North" = "#2ca02c",
  "Far North"  = "#d62728"
)

scenario_sets <- list(
  S0 = c("eTT.BG.Ce", "eTT.BG.So"),                      # 3 Central, 1 South
  S1 = c("eTT.BG.Ce", "eTT.BG.NN"),                      # 3 Central, 1 Near North
  S2 = c("eTT.BG.Ce", "eTT.BG.FN"),                      # 3 Central, 1 Far North
  S3 = c("eTT.BG.Ce", "eTT.BG.So", "eTT.BG.NN"),         # 2 Central, 1 South, 1 Near North
  S4 = c("eTT.BG.Ce", "eTT.BG.So", "eTT.BG.FN")          # 2 Central, 1 South, 1 Far North
)

# Ensure we have an ID per call
ems <- ems %>% mutate(call_id = row_number())

winners <- map_dfr(names(scenario_sets), function(scn) {
  cols <- scenario_sets[[scn]]

  ems %>%
    select(call_id, REF.GPS.LAT, REF.GPS.LON, all_of(cols)) %>%
    rowwise() %>%
    mutate(
      scenario = scn,
      # scalar min across the active columns (treat NAs as Inf so they can't "win")
      resp_sec = min(replace_na(c_across(all_of(cols)), Inf)),
      # find index of the minimum and map to station label
      fastest  = station_names[ cols[ which.min(replace_na(c_across(all_of(cols)), Inf)) ] ]
    ) %>%
    ungroup() %>%
    select(call_id, REF.GPS.LAT, REF.GPS.LON, scenario, fastest, resp_sec)
})
ggplot(winners, aes(REF.GPS.LON, REF.GPS.LAT, color = fastest)) +
  geom_point(alpha = 0.55, size = 1.4) +
  scale_color_manual(values = station_palette, name = "Fastest station") +
  coord_quickmap() +
  facet_wrap(~ scenario, ncol = 3) +
  labs(
    title = "Fastest station by scenario  (eTT)",
    x = "Longitude", y = "Latitude"
  ) +
  theme_bw(base_size = 12) +
  theme(legend.position = "bottom")


```

The faceted maps illustrate how the geographic coverage of the fastest stations shifts under different station allocations. Under the current system (S0), most calls are served by Central and South, with Central dominating northern calls. In S1, the introduction of a Near North station allows some northern calls to be captured by that base, although Central still handles the majority. In S2, adding a Far North station shifts coverage of the northernmost calls away from Central, though the overall impact is limited to a smaller set of points. Scenarios S3 and S4, which reduce Central capacity to two ambulances while introducing Near North or Far North coverage, show clearer redistribution: The Near North (S3) and Far North (S4) stations assume responsibility for portions of the northern district, while Central and South continue to dominate elsewhere. Taken together, the map suggests that a Near North station (s1/S3) provides more widespread northern coverage than a Far North station, though both options reduce reliance on Central for calls in the northernmost areas. This supports the conclusion that strategically relocating one unit north can improve equity of service across regions, particularly in the underserved North district.

### Modeling

```{r}
library(emmeans)
ems_long <- ems_long %>%
  mutate(meet8 = ifelse(RespTime_min <= 8, 1, 0))


fit_logit <- glm(meet8 ~ Scenario * REF.GRID,
                 data = ems_long,
                 family = binomial)

summary(fit_logit)   

pred_probs <- emmeans(fit_logit, ~ Scenario | REF.GRID, type = "response")
pred_df <- as.data.frame(pred_probs)  
head(pred_df)


ggplot(pred_df, aes(x=Scenario, y=prob*100, fill=REF.GRID)) +
  geom_col(position="dodge") +
  geom_errorbar(aes(ymin=asymp.LCL*100,
                    ymax=asymp.UCL*100),
                position=position_dodge(0.9), width=0.2) +
  labs(title="% of Calls Under 8-Minute Benchmark (Model-Based)",
       y="% Calls Under 8 Minutes", x="Scenario", fill="District") +
  theme_minimal()

delta_df <- pred_df %>%
  group_by(REF.GRID) %>%
  mutate(delta_vs_S0 = (prob - prob[Scenario=="S0"])*100)

ggplot(delta_df, aes(x=Scenario, y=delta_vs_S0, fill=REF.GRID)) +
  geom_col(position="dodge") +
  labs(title="Improvement Over Current (S0)",
       y="Change in % of Calls Under 8 min",
       x="Scenario", fill="District") +
  theme_minimal()

```

### Workload/Busy Ratio

```{r}
x <- x %>%
  mutate(dispToClear_mins = as.numeric(difftime(DT.AVAILABLE, DT.DISP, units="mins")),
         onScene_mins = as.numeric(onSceneDur/60))

x %>% group_by(VEH.GRID) %>%
  summarise(mean_busy_time = mean(dispToClear_mins, na.rm=TRUE),
            calls_handled = n()) %>%
  ggplot(aes(x=reorder(VEH.GRID, -calls_handled), y=calls_handled, fill=mean_busy_time)) +
  geom_col() + 
  scale_fill_viridis_c() +
  labs(title="Workload by Ambulance", x="Ambulance", y="Calls Handled")
```

```{r}

x <- x %>%
  mutate(
    DT.DISP      = as.POSIXct(DT.DISP, format="%m/%d/%Y %H:%M:%S", tz="EST"),
    DT.ENROUTE   = as.POSIXct(DT.ENROUTE, format="%m/%d/%Y %H:%M:%S", tz="EST"),
    DT.ARRIVE    = as.POSIXct(DT.ARRIVE, format="%m/%d/%Y %H:%M:%S", tz="EST"),
    DT.LVREF     = as.POSIXct(DT.LVREF, format="%m/%d/%Y %H:%M:%S", tz="EST"),
    DT.ARVREC    = as.POSIXct(DT.ARVREC, format="%m/%d/%Y %H:%M:%S", tz="EST"),
    DT.AVAILABLE = as.POSIXct(DT.AVAILABLE, format="%m/%d/%Y %H:%M:%S", tz="EST")
  )

x <- x %>%
  mutate(
    busy_time = as.numeric(difftime(DT.AVAILABLE, DT.DISP, units="mins"))
  )

busy_stats <- x %>%
  group_by(VEH.GRID) %>%
  summarise(
    total_busy_hr = sum(busy_time, na.rm=TRUE)/60,
    calls = n()
  ) %>%
  mutate(shift_hr = 24*30,  
         busy_fraction = total_busy_hr / shift_hr)

busy_stats

ggplot(x, aes(x=DT.DISP, y=VEH.GRID, color=busy_time)) +
  geom_segment(aes(xend=DT.AVAILABLE, yend=VEH.GRID), size=2) +
  labs(title="Ambulance Busy Intervals (Dispatch → Available)",
       x="Time", y="Ambulance")
```

```{r}
ggplot(x %>% filter(grepl("North", REF.GRID)), 
       aes(x = eTT.BG.NN/60, y = eTT.BG.FN/60)) +
  geom_point(alpha=0.4, color="blue") +
  geom_abline(slope=1, intercept=0, lty=2, color="red") +
  labs(title="Near vs Far North Predicted Response Times (North District Calls)",
       x="Near North Travel Time (min)", 
       y="Far North Travel Time (min)") +
  theme_minimal()

x %>% 
  filter(grepl("North", REF.GRID)) %>%
  summarise(
    mean_NN = mean(eTT.BG.NN, na.rm=TRUE)/60,
    mean_FN = mean(eTT.BG.FN, na.rm=TRUE)/60,
    median_NN = median(eTT.BG.NN, na.rm=TRUE)/60,
    median_FN = median(eTT.BG.FN, na.rm=TRUE)/60,
    avg_diff = mean((eTT.BG.FN - eTT.BG.NN)/60, na.rm=TRUE)  #farnorth - nearnorth
  )
```

Travel time = turnout (DT.Enroute - DT.DISP) + drive time to the scene (eTT)

```{r}
# 1) Build turnout (dispatch -> enroute) in minutes
ems_tt <- ems %>%
  filter(!is.na(DT.DISP), !is.na(DT.ENROUTE)) %>%
  mutate(
    turnout_min = as.numeric(difftime(DT.ENROUTE, DT.DISP, units = "mins")),
    # convert Google best-guess ETAs to minutes (drop /60 if already minutes)
    ce_bg_min = eTT.BG.Ce / 60,
    so_bg_min = eTT.BG.So / 60,
    nn_bg_min = eTT.BG.NN / 60,
    fn_bg_min = eTT.BG.FN / 60
  ) %>%
  # 2) Scenario-specific driving ETA (NA-safe; if all NA for a row, keep NA)
  rowwise() %>%
  mutate(
    eta_S0 = {v <- c(ce_bg_min, so_bg_min);            v <- ifelse(is.na(v), Inf, v); m <- min(v); if (is.infinite(m)) NA_real_ else m},
    eta_S1 = {v <- c(ce_bg_min, nn_bg_min);            v <- ifelse(is.na(v), Inf, v); m <- min(v); if (is.infinite(m)) NA_real_ else m},
    eta_S2 = {v <- c(ce_bg_min, fn_bg_min);            v <- ifelse(is.na(v), Inf, v); m <- min(v); if (is.infinite(m)) NA_real_ else m},
    eta_S3 = {v <- c(ce_bg_min, so_bg_min, nn_bg_min); v <- ifelse(is.na(v), Inf, v); m <- min(v); if (is.infinite(m)) NA_real_ else m},
    eta_S4 = {v <- c(ce_bg_min, so_bg_min, fn_bg_min); v <- ifelse(is.na(v), Inf, v); m <- min(v); if (is.infinite(m)) NA_real_ else m}
  ) %>%
  ungroup() %>%
  # 3) Travel time per scenario = turnout + scenario ETA (minutes)
  mutate(
    tt0 = turnout_min + eta_S0,   # S0 (Current: Ce + So)
    tt1 = turnout_min + eta_S1,   # S1 (Ce + NN)
    tt2 = turnout_min + eta_S2,   # S2 (Ce + FN)
    tt3 = turnout_min + eta_S3,   # S3 (Ce + So + NN)
    tt4 = turnout_min + eta_S4    # S4 (Ce + So + FN)
  )

# 4) Long format (tidy)
tt_long <- ems_tt %>%
  mutate(call_id = row_number()) %>%
  select(call_id, REF.GRID, starts_with("tt")) %>%
  pivot_longer(
    cols = starts_with("tt"),
    names_to = "Scenario",
    values_to = "TravelTime_min"
  ) %>%
  mutate(
    Scenario = factor(Scenario,
                      levels = c("tt0","tt1","tt2","tt3","tt4"),
                      labels = c("S0","S1","S2","S3","S4"))
  )

glimpse(tt_long)

```

```{r}
ggplot(tt_long, aes(x=Scenario, y=TravelTime_min, fill=Scenario)) +
  geom_boxplot(outlier.alpha=0.15) +
  facet_wrap(~REF.GRID) +
  geom_hline(yintercept=8, linetype="dashed", color="red") +
  labs(title="Scenario Comparisons by District",
       y="Response Time (minutes)", x="Scenario") +
  theme_minimal()
```

```{r}
tt_long %>%
  ggplot(aes(x = Scenario, y = TravelTime_min, fill = Scenario)) +
  geom_boxplot(outlier.shape = NA) +
  coord_cartesian(ylim = c(0, 10)) +   # adjust as needed
  labs(
    title = "Response time by scenario",
    x = "Scenario",
    y = "Estimated response time (minutes)"    # change to seconds if needed
  ) +
  theme_minimal() +
  theme(legend.position = "none")

```

====YURA====

Order each ambulance's dispatch time\
\* Each row: one call by that specific truck

```{r}
# order dispatches and compute diffs per truck 
ems_calls <- ems %>%
  select(VEH.GRID, DT.DISP, DT.AVAILABLE) %>%
  filter(!is.na(DT.DISP)) %>%
  mutate(
    DT.DISP      = as_datetime(DT.DISP),
    DT.AVAILABLE = as_datetime(DT.AVAILABLE)
  ) %>%
  arrange(VEH.GRID, DT.DISP) %>% # sort chronologically per medic
  group_by(VEH.GRID) %>%
  mutate(
    call_index     = row_number(), # order each medic's calls
    dispatch_gap_m = as.numeric(difftime(DT.DISP, lag(DT.DISP), units = "mins")) # gap since last call
  ) %>%
  ungroup()

ems_calls
```

Extract k-th dispatch/available time per unit & build one vector of dispatch time, one vector of availble times.

```{r}
library(purrr)
library(stringr)

# reutrn k-th timestamp for a given truct and disp & avail time
kth_time <- function(df, unit, k, col) {
  v <- df %>%
    filter(VEH.GRID == unit) %>%     # keep rows for this ambulance only
    arrange(DT.DISP) %>%             # order that unit’s calls chronologically
    pull({{ col }})                  # pull the chosen timestamp column (tidy-eval)
  if (length(v) >= k) v[[k]] else as.POSIXct(NA_real_, tz = "UTC")  # return k-th or NA
}

occ_idx <- 1 # which occurence index to compare (e.g. 1 == first run per unit)

# Medic 1-7
units <- ems_calls %>%
  distinct(VEH.GRID) %>%
  mutate(ord = as.integer(str_extract(VEH.GRID, "\\d+"))) %>%
  arrange(ord) %>%
  pull(VEH.GRID)


disp_vec  <- do.call(c, map(units, ~ kth_time(ems_calls, .x, occ_idx, DT.DISP)))
avail_vec <- do.call(c, map(units, ~ kth_time(ems_calls, .x, occ_idx, DT.AVAILABLE)))

avail_vec
```

# build 7x7 T/F matrix

x\[i, j\] is TRUE if Medic i's k-th dispatch time \<= Medic j's k-th available time

```{r}
x <- outer(disp_vec, avail_vec, FUN = function(a,b) a<= b)

# Zero upper triangle + diagonal to avoid duplicates/self-comparisons
x[upper.tri(x, diag = TRUE)] <- FALSE

x
```

Ex: row 5 (Medic 5): Col 1-4 are true, meaning when Medic 5 dispatched, medics 1-4 were still busy \\ Row 7: only medic 3-4 were not back yet when medic 7 dispatched \\

Conflict rule ftn??: \* for each call, tracks location closest \* if fastest is NN/FN, assign it immediately \* otherwise, pick from BASE.NAME pick one who is free at DT.DISP \* if none are free, choose the one who becomes free soonest and add wait penalty

sreya

```{r model}
library(lme4)
library(emmeans)
tt_long <- tt_long %>%
  mutate(
    Scenario = factor(Scenario, levels = c("S0","S1","S2","S3","S4")),
    log_tt = log(TravelTime_min)
  )

m_tt <- lmer(log_tt ~ Scenario + (1 | call_id), data = tt_long, REML = TRUE)
summary(m_tt)
```

```{r}
library(performance)

tt_long$fit_log   <- fitted(m_tt)              # fitted on log scale
tt_long$resid_raw <- resid(m_tt, type = "response")  # residuals on log scale
tt_long$resid_std <- resid(m_tt, type = "pearson")   # Pearson standardized residuals

# QQ plot of residuals (log scale)
ggplot(tt_long, aes(sample = resid_raw)) +
  stat_qq(alpha = 0.5) +
  stat_qq_line(color = "red") +
  labs(title = "QQ plot of residuals (log scale)",
       x = "Theoretical Quantiles", y = "Sample Quantiles") +
  theme_minimal()

# Residuals vs fitted (log scale)
ggplot(tt_long, aes(x = fit_log, y = resid_raw)) +
  geom_point(alpha = 0.4) +
  geom_hline(yintercept = 0, color = "red", linetype = "dashed") +
  labs(title = "Residuals vs Fitted (log scale)",
       x = "Fitted log response time", y = "Residuals (log)") +
  theme_minimal()

# Scale-Location plot (sqrt(|standardized residuals|) vs fitted)
ggplot(tt_long, aes(x = fit_log, y = sqrt(abs(resid_std)))) +
  geom_point(alpha = 0.4) +
  geom_smooth(se = FALSE, color = "blue") +
  labs(title = "Scale-Location",
       x = "Fitted log response time", y = "Sqrt(|standardized residuals|)") +
  theme_minimal()

# One-stop shop diagnostics (optional)
performance::check_model(m_tt)  # opens a panel of diagnostic plots
```

```{r}
re_call <- ranef(m_tt)$call_id[,1, drop = TRUE]  # random intercepts
qqnorm(re_call, main = "QQ plot of random intercepts (call_id)")
qqline(re_call, col = "red")
```

```{r}
# R2 (marginal = fixed effects only; conditional = fixed + random)
performance::r2_nakagawa(m_tt)

# Predictions and residuals on log scale
pred_log_fe   <- predict(m_tt, re.form = NA)     # fixed effects only
pred_log_full <- predict(m_tt, re.form = NULL)   # fixed + random

res_log_fe    <- tt_long$log_tt - pred_log_fe
res_log_full  <- tt_long$log_tt - pred_log_full

RMSE_log_fe   <- sqrt(mean(res_log_fe^2))
MAE_log_fe    <- mean(abs(res_log_fe))
RMSE_log_full <- sqrt(mean(res_log_full^2))
MAE_log_full  <- mean(abs(res_log_full))

# Back-transform to minutes (note: exp(pred_log) is median on minutes scale)
pred_min_full <- exp(pred_log_full)
RMSE_min      <- sqrt(mean((tt_long$TravelTime_min - pred_min_full)^2))
MAE_min       <- mean(abs(tt_long$TravelTime_min - pred_min_full))

c(RMSE_log_fe = RMSE_log_fe, MAE_log_fe = MAE_log_fe,
  RMSE_log_full = RMSE_log_full, MAE_log_full = MAE_log_full,
  RMSE_min = RMSE_min, MAE_min = MAE_min)

# ICC (proportion of variance due to call-level random intercept)
vc <- as.data.frame(VarCorr(m_tt))
var_call <- vc$vcov[vc$grp == "call_id"]
var_res  <- vc$vcov[vc$grp == "Residual"]
ICC <- var_call / (var_call + var_res)
ICC
```

```{r}
library(emmeans)
library(dplyr)

emm_log <- emmeans(m_tt, ~ Scenario)

# Back-transform to minutes (geometric mean) and rank (lower = better)
emm_min <- as.data.frame(summary(emm_log)) %>%
  transmute(
    Scenario,
    minutes   = exp(emmean),
    lower_CL  = exp(lower.CL),
    upper_CL  = exp(upper.CL)
  ) %>%
  arrange(minutes)

emm_min   # choose the scenario with the smallest 'minutes' here

# # Percent change vs S0
# ctr_vs_S0 <- contrast(emm_log, method = "trt.vs.ctrl", ref = "S0")
# pct_vs_S0 <- as.data.frame(summary(ctr_vs_S0)) %>%
#   transmute(
#     contrast,
#     pct_change = (exp(estimate) - 1) * 100,
#     lwr        = (exp(lower.CL) - 1) * 100,
#     upr        = (exp(upper.CL) - 1) * 100,
#     p.value
#   )
# 
# pct_vs_S0  # negative pct_change means faster than S0
```

NEW CODE:

```{r}
library(dplyr)
library(geosphere)

# 1️⃣ Define which stations are available in each scenario
station_scenarios <- list(
  S0 = c("South", "Central"),
  S1 = c("Near North", "Central"),
  S2 = c("Far North", "Central"),
  S3 = c("Near North", "Central", "South"),
  S4 = c("Far North", "Central", "South")
)

# 2️⃣ Define coordinates for each station (replace with your own or derive from VEHCGPS if available)
station_coords <- data.frame(
  station = c("South", "Central", "Near North", "Far North"),
  lat = c(35.76, 35.89, 35.98, 36.05),
  lon = c(-78.64, -78.91, -78.88, -78.75)
)

# 3️⃣ Function: find closest available station based on distance
get_closest_station <- function(call_lat, call_lon, available_regions) {
  coords <- station_coords %>% filter(station %in% available_regions)
  if (nrow(coords) == 0) return(NA)
  dists <- distHaversine(cbind(coords$lon, coords$lat), c(call_lon, call_lat))
  coords$station[which.min(dists)]
}

# 4️⃣ Function: build scenario dataset
build_scenario <- function(data, scenario_name) {
  regions <- station_scenarios[[scenario_name]]
  
  data <- data %>%
    arrange(DT.DISP) %>%
    mutate(
      available_stations = paste(regions, collapse = ", "),
      
      # Find closest available station for each call
      closest_station = mapply(get_closest_station, REF.GPS.LAT, REF.GPS.LON, 
                               MoreArgs = list(available_regions = regions)),
      
      # Compute service time & time until next call
      total_service_secs = as.numeric(difftime(DT.AVAILABLE, DT.DISP, units = "secs")),
      time_until_next_call = as.numeric(difftime(lead(DT.DISP), DT.DISP, units = "secs"))
    )
  
  # Add "next free" wait time if no ambulance is available
  data <- data %>%
    mutate(
      next_free_secs = ifelse(is.na(closest_station),
                              min(total_service_secs, na.rm = TRUE),
                              0),
      effective_response_time = total_service_secs + next_free_secs,
      can_handle_next = effective_response_time < time_until_next_call
    )
  
  return(data)
}

# 5️⃣ Build datasets for all 5 scenarios
ems_S0 <- build_scenario(ems, "S0")
ems_S1 <- build_scenario(ems, "S1")
ems_S2 <- build_scenario(ems, "S2")
ems_S3 <- build_scenario(ems, "S3")
ems_S4 <- build_scenario(ems, "S4")

# ✅ Check counts
nrow(ems)
nrow(ems_S0)

```

```{r}
ems_S0
```

```{r}
ems_S3
```
